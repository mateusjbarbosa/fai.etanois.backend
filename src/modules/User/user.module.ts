import * as crypto from 'crypto'
import Redis from '../../core/redis/redis';

export enum EUserRoles {
  ADMIN = 'admin',
  DRIVER = 'driver',
  ATTENDANT = 'attendant',
  GAS_STATION_OWNER = 'gas_station_owner'
}

export enum EPaymentMode {
  BOTH = 'both',
  MONEY = 'money',
  CREDIT_CARD = 'credit_card'
}

export interface IUser {
  readonly id: number,
  phone_number?: string,
  email?: string,
  name: string,
  password: string,
  cep: string,
  search_distance: number,
  payment_mode: EPaymentMode,
  etacoins?: number
  role?: EUserRoles,
  UserPreferenceFuels?: IUserPreferenceFuel[]
}

export interface IUserDetail {
  readonly id: number,
  phone_number: string,
  email: string,
  name: string,
  cep: string,
  payment_mode: string,
  search_distance: number,
  etacoins?: number
  UserPreferenceFuels?: IUserPreferenceFuel[]
}

export interface IUserPreferenceFuel {
  fuel_name: string
}

export interface IUserForAuthorization {
  id: number,
  phone_number?: string,
  email?: string,
  password: string,
  role: EUserRoles
}

export function create(user: any): IUserDetail {
  let userObject:any = null;

  try{
    if (user.dataValues.hasOwnProperty('id')) { // User generated by read
      userObject = user;
    }
  } catch(err) {
    if (user[1][0].dataValues.hasOwnProperty('id')) { // User generated by update
      userObject = user[1][0].dataValues;
    }
  }
  
  if (userObject) {
    const {id, search_distance, phone_number, email, name, cep, payment_mode,
      etacoins, UserPreferenceFuels} = userObject;
      
      if (UserPreferenceFuels) {
        UserPreferenceFuels.forEach(item => {
          delete item.dataValues.id
          delete item.dataValues.user_id
          delete item.dataValues.createdAt
          delete item.dataValues.updatedAt
        })
      }
      
    return {id, phone_number, email, name, cep, payment_mode, search_distance, etacoins,
      UserPreferenceFuels};
  }

  return null
}

export function getUserForAuthorization(user: any): IUserForAuthorization {
  let userAuthoriation: IUserForAuthorization = {
    id: null,
    email: null,
    phone_number: null,
    password: null,
    role: null
  };
  
  if (user) {
    const keys = Object.keys(user._previousDataValues);

    keys.forEach(property => {
      switch (property)
      {
        case 'id':
          userAuthoriation.id = user[property];
        break;

        case 'phone_number':
          userAuthoriation.phone_number = user[property];
        break;

        case 'email':
          userAuthoriation.email = user[property];
        break;

        case 'role':
          userAuthoriation.role = user[property];
        break;

        case 'password':
          userAuthoriation.password = user[property];
        break;
      }
    });

    return userAuthoriation;
  }

  return null;
}

export function createUsers(data: any[]): IUserDetail[] {
  return data.map(create);
}

export async function generateRandomToken(user: any): Promise<any> {
  if (user) {
    const { id } = user;

    return new Promise(resolve => {
      crypto.randomBytes(20, (err, buffer) => {
        const token = buffer.toString('hex')
        
        Redis.createRecoverPassword(token, id)
        resolve({token: token})
      });
    });
  } else {
    throw new Error('User not found').message;
  }
}